<?xml version="1.0" encoding="utf-8"?>
<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
  <edmx:Reference Uri="https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml">
    <edmx:Include Alias="Core" Namespace="Org.OData.Core.V1" />
  </edmx:Reference>
  <edmx:Reference Uri="https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml">
    <edmx:Include Alias="Aggregation" Namespace="Org.OData.Aggregation.V1" />
  </edmx:Reference>
  <edmx:Reference Uri="https://sap.github.io/odata-vocabularies/vocabularies/Common.xml">
    <edmx:Include Namespace="com.sap.vocabularies.Common.v1" Alias="Common" />
  </edmx:Reference>

  <edmx:DataServices>
    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="com.sap.vocabularies.Hierarchy.v1" Alias="Hierarchy">
      <Annotation Term="Core.Description">
        <String>Terms for Hierarchies</String>
      </Annotation>
      <Annotation Term="Core.Description" Qualifier="Published">
        <String>2018-01-31 © Copyright 2018 SAP SE. All rights reserved</String>
      </Annotation>
      <Annotation Term="Core.Links">
        <Collection>
          <Record>
            <PropertyValue Property="rel" String="latest-version" />
            <PropertyValue Property="href" String="https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.xml" />
          </Record>
          <Record>
            <PropertyValue Property="rel" String="alternate" />
            <PropertyValue Property="href" String="https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.json" />
          </Record>
          <Record>
            <PropertyValue Property="rel" String="describedby" />
            <PropertyValue Property="href" String="https://github.com/sap/odata-vocabularies/blob/main/vocabularies/Hierarchy.md" />
          </Record>
        </Collection>
      </Annotation>

      <Term Name="RecursiveHierarchy" Type="Hierarchy.RecursiveHierarchyType" BaseTerm="Aggregation.RecursiveHierarchy" Nullable="false" AppliesTo="EntityType">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.Description" String="Defines a recursive hierarchy" />
        <Annotation Term="Core.LongDescription">
          <String>The [base term](https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.html#RecursiveHierarchy)
          governs what are the nodes and parents in the hierarchy, whereas this annotation designates properties that contain derived information
          and actions for manipulating the hierarchy.</String>
        </Annotation>
      </Term>
      <ComplexType Name="RecursiveHierarchyType">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.LongDescription">
          <String>The property paths in this complex type refer to properties of an entity type that contain
information about a node in a recursive hierarchy. When hierarchical transformations
are applied whose first parameter has the annotated entity type
and whose second parameter is the annotation qualifier,
then these properties are derived for each node in the result set.
Otherwise, the property paths may evaluate to null.

For requests like
```
SalesOrganizations?$apply=
descendants(..., ID, filter(ID eq 'US'), keep start)
/ancestors(..., ID, filter(contains(Name, 'New York'), keep start)
/Hierarchy.TopLevels(..., NodeProperty='ID', Levels=2)
&amp;$top=10
```
or
```
SalesOrganizations?$apply=groupby((rolluprecursive(..., ID,
  descendants(..., ID, filter(ID eq 'US')),
  ancestors(..., ID, filter(contains(Name, 'New York')), keep start))), aggregate(...))
/Hierarchy.TopLevels(..., NodeProperty='ID', Levels=2)
&amp;$top=10
```
(where `...,` stands for hierarchy nodes and hierarchy qualifier)
the following collections of hierarchy nodes are distinguished:
|Collection|Definition|Value|Where in request|
|----------|----------|-----|----------------|
|sub-hierarchy|output set of a `descendants` transformation, possibly embedded in a `rolluprecursive` transformation, that is not preceded by an `ancestors` or `descendants` transformation|US sales organizations|rows 1–2|
|matching nodes|see [`MatchCount`](#MatchCount)|US sales organizations with "New York" in their name|output set of `filter` transformation in row 3|
|unlimited hierarchy|output set of the last `ancestors`, `descendants` or `traverse` transformation, possibly embedded in a `rolluprecursive` transformation, disregarding numeric fifth parameters|US sales organizations with leaves containing "New York"|rows 1–3|
|limited hierarchy|output set of the last `ancestors`, `descendants`, `traverse` or [`Hierarchy.TopLevels`](#TopLevels) transformation, possibly embedded in a `rolluprecursive` transformation|2 levels of US sales organizations with leaves containing "New York"|rows 1–4|

The qualified action names identify bound actions for maintaining nodes in the recursive hierarchy.
These actions MUST have the same signature as the template actions linked below, with
`Edm.EntityType` replaced with the entity type on which the recursive hierarchy is defined.
When invoking an action, clients MUST set the `HierarchyQualifier` to the qualifier of the [`RecursiveHierarchy`](#RecursiveHierarchy) annotation.
In parameters of entity type that are defined as "Key of …", only the key properties are relevant.

The resource path identifying the binding parameter MUST traverse the collection of hierarchy nodes.
If the action invocation appears in a batch request, the resource path MUST contain a dependency
to the result of an earlier POST request whose resource path traversed the collection of hierarchy nodes.[create action](#Template_CreateAction) or [create-child action](#Template_CreateChildAction) from the same batch request.

The template actions themselves cannot be invoked.
</String>
        </Annotation>
        <Property Name="ExternalKeyProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="String property holding the human-readable key value for a node" />
          <Annotation Term="Core.LongDescription">
            <String>If a `NodeTypeProperty` exists, the external key is unique only in combination with it.
            Or the external key can coincide with the [`Aggregation.RecursiveHierarchy/NodeProperty`](https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.html#RecursiveHierarchyType).</String>
          </Annotation>
        </Property>
        <Property Name="NodeTypeProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="String property holding the type of a node" />
          <Annotation Term="Core.LongDescription">
            <String>In a recursive hierarchy with mixed types, nodes can
            &lt;br&gt;- have a type-specific (navigation) property whose name is the node type or
            &lt;br&gt;- be represented by entities of different subtypes of a common entity type that is
            annotated with the `RecursiveHierarchy` annotation. The qualified name of the subtype is the node type.</String>
          </Annotation>
        </Property>
        <Property Name="ChildCountProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the number of children a node has in the unlimited hierarchy" />
        </Property>
        <Property Name="DescendantCountProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the number of descendants a node has in the unlimited hierarchy" />
        </Property>
        <Property Name="LimitedDescendantCountProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the number of descendants a node has in the limited hierarchy" />
        </Property>
        <Property Name="DrillStateProperty" Type="Edm.PropertyPath" Nullable="false">
          <Annotation Term="Core.Description" String="String property holding the drill state of a node" />
          <Annotation Term="Core.LongDescription">
            <String>Possible drill states are:
            &lt;br&gt;- `expanded` if a node has children in the limited hierarchy
            &lt;br&gt;- `collapsed` if a node has children in the unlimited hierarchy but not in the limited hierarchy
            &lt;br&gt;- `leaf` if a node has no children in the unlimited hierarchy</String>
          </Annotation>
        </Property>
        <Property Name="DistanceFromRootProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the number of ancestors a node has in the limited hierarchy" />
          <Annotation Term="Core.LongDescription">
            <String>This equals the number of ancestors in the sub-hierarchy as well as in the unlimited hierarchy.</String>
          </Annotation>
        </Property>
        <Property Name="SiblingRankProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the sibling rank of a node" />
          <Annotation Term="Core.LongDescription">
            <String>The sibling rank of a node is the index of the node in the sequence of all nodes
            in the unlimited hierarchy with the same parent. The first sibling has rank 0.</String>
          </Annotation>
        </Property>
        <!--
        <Property Name="SiblingOrderProperties" Type="Collection(Edm.PropertyPath)" Nullable="false">
          <Annotation Term="Core.Description" String="Properties that define the relative order of siblings" />
          <Annotation Term="Core.LongDescription" String="A PATCH request on these properties changes the relative order of siblings." />
        </Property>
        -->
        <Property Name="MatchedProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Boolean property indicating [matching](#MatchCount) nodes" />
        </Property>
        <Property Name="MatchedDescendantCountProperty" Type="Edm.PropertyPath" Nullable="true">
          <Annotation Term="Core.Description" String="Integer property of type `Edm.Int64` holding the the number of [matching](#MatchCount) descendants a node has in the unlimited hierarchy" />
        </Property>
        <!--
        <Property Name="StartNodeCountsSupported" Type="Core.Tag" Nullable="false" DefaultValue="false">
          <Annotation Term="Core.Description" String="Whether the service provides the [`StartNodeCounts`](#StartNodeCounts) instance annotation" />
        </Property>
        -->
        <Property Name="LinkAction" Type="Core.QualifiedActionName" Nullable="true">
          <Annotation Term="Core.Description" String="Action that links a node to a parent, following [this template](#Template_LinkAction)" />
        </Property>
        <Property Name="UnlinkAction" Type="Core.QualifiedActionName" Nullable="true">
          <Annotation Term="Core.Description" String="Action that unlinks a node from a parent, following [this template](#Template_UnlinkAction)" />
        </Property>
        <Property Name="PositionAction" Type="Core.QualifiedActionName" Nullable="true">
          <Annotation Term="Core.Description" String="Action that positions a node among its siblings, following [this template](#Template_PositionAction)" />
        </Property>
      </ComplexType>

      <Term Name="MatchCount" Type="Edm.Int64" Nullable="false" AppliesTo="Collection">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Common.IsInstanceAnnotation" />
        <Annotation Term="Core.Description" String="Instance annotation on the result of an `$apply` query option containing the number of matching nodes after hierarchical transformations" />
        <Annotation Term="Core.LongDescription">
          <String>The service designates a subset of the `$apply` result as "matching nodes".
          This subset is the output set of the `filter` or `search` transformation that occurs as the fourth parameter
          of the last `ancestors` transformation or occurs nested into it.&lt;br&gt;
          This instance annotation is available if [`RecursiveHierarchy/MatchedProperty`](#RecursiveHierarchyType)
          and `RecursiveHierarchy/MatchedDescendantCountProperty` are also available.</String>
        </Annotation>
      </Term>

      <!--
      <Term Name="StartNodeCounts" Type="Collection(Edm.Int64)" AppliesTo="Collection">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Common.IsInstanceAnnotation" />
        <Annotation Term="Core.Description" String="Instance annotation on the result of an `$apply` query option containing the number of start nodes for each `ancestors` or `descendants` transformation" />
        <Annotation Term="Core.LongDescription">
          <String>The annotation value is an integer collection whose n-th entry is the number of start nodes determined
          for the n-th `ancestors` or `descendants` transformation in the order in which they occur in the `$apply` query option.
          Start nodes are determined by the fourth parameter of an `ancestors` or `descendants` transformation.</String>
        </Annotation>
      </Term>
      -->

      <Function Name="TopLevels" IsBound="true" EntitySetPath="InputSet">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.Description" String="Returns the first n levels of a hierarchical collection in preorder with individual nodes expanded or collapsed" />
        <Annotation Term="Core.LongDescription">
          <String>This function can be used as a transformation whose input set has a recursive hierarchy
          defined by an [`Aggregation.RecursiveHierarchy`](https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.html#RecursiveHierarchy)
          annotation on the entity type of the `HierarchyNodes`.
          (Its binding parameter is the unlimited hierarchy as defined [here](#RecursiveHierarchyType),
          its output is the limited hierarchy.) The output initially contains the nodes with less than n ancestors
          in the hierarchical collection given in the binding parameter.
          Then individual nodes are expanded, shown or collapsed in the output, which extends or reduces the limited hierarchy.
          Finally the output is sorted in preorder as with the `traverse` transformation.</String>
        </Annotation>
        <Parameter Name="InputSet" Type="Collection(Edm.EntityType)" Nullable="false"/>
        <Parameter Name="HierarchyNodes" Type="Collection(Edm.EntityType)" Nullable="false">
          <Annotation Term="Core.Description" String="A collection, given through a `$root` expression" />
        </Parameter>
        <Parameter Name="HierarchyQualifier" Type="Aggregation.HierarchyQualifier" Nullable="false" />
        <Parameter Name="NodeProperty" Type="Edm.String" Nullable="false">
          <Annotation Term="Core.Description" String="Property path to the node identifier, evaluated relative to the binding parameter" />
        </Parameter>
        <Parameter Name="Levels" Type="Edm.Int64" Nullable="false">
          <Annotation Term="Core.Description" String="The number n of levels to be output, absent means all levels" />
          <Annotation Term="Core.OptionalParameter">
            <Record/>
          </Annotation>
          <Annotation Term="Validation.Minimum" Int="1" />
        </Parameter>
        <Parameter Name="Expand" Type="Collection(Edm.String)" Nullable="false">
          <Annotation Term="Core.Description" String="Identifiers of nodes to be expanded" />
          <Annotation Term="Core.OptionalParameter">
            <Record/>
          </Annotation>
        </Parameter>
        <Parameter Name="Show" Type="Collection(Edm.String)" Nullable="false">
          <Annotation Term="Core.Description" String="Identifiers of nodes to be shown" />
          <Annotation Term="Core.OptionalParameter">
            <Record/>
          </Annotation>
        </Parameter>
        <Parameter Name="Collapse" Type="Collection(Edm.String)" Nullable="false">
          <Annotation Term="Core.Description" String="Identifiers of nodes to be collapsed" />
          <Annotation Term="Core.OptionalParameter">
            <Record/>
          </Annotation>
        </Parameter>
        <ReturnType Type="Collection(Edm.EntityType)" />
      </Function>

      <Action Name="Template_LinkAction" IsBound="true">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.Description" String="Template for actions that link a node to a parent and are named in [`RecursiveHierarchy/LinkAction`](#RecursiveHierarchyType)" />
        <Annotation Term="Core.LongDescription">
          <String>In single-parent hierarchies, the node is first unlinked from its current parent, if any.

To create a new node as child of an existing parent, this action can be used in a JSON batch request like:
```
{"requests": [{
  "id": "1",
  "method": "post",
  "url": "HierarchyDirectory(1)/SalesOrganizations",
  "body": {"Name": "EMEA", ...}
}, {
  "id": "2",
  "dependsOn": ["1"],
  "method": "post",
  "url": "$1/LinkAction",
  "body": {
    "HierarchyQualifier": "SalesOrgHierarchy",
    "Parent": {"Name": "Worldwide"}
  }
}]}
```
The second request inherits the hierarchy directory key 1 from the first.</String>
        </Annotation>
        <Parameter Name="Entity" Type="Edm.EntityType" Nullable="false">
          <Annotation Term="Core.Description" String="The entity to become a child" />
        </Parameter>
        <Parameter Name="HierarchyQualifier" Type="Aggregation.HierarchyQualifier" Nullable="false">
          <Annotation Term="Core.Description" String="Qualifier of a [`RecursiveHierarchy`](#RecursiveHierarchy) annotation on the binding parameter's entity type" />
        </Parameter>
        <Parameter Name="Parent" Type="Edm.EntityType" Nullable="false">
          <Annotation Term="Core.Description" String="Key of the entity's new parent" />
        </Parameter>
      </Action>
      <Action Name="Template_UnlinkAction" IsBound="true">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.Description" String="Template for actions that unlink a node from a parent and are named in [`RecursiveHierarchy/UnlinkAction`](#RecursiveHierarchyType)" />
        <Parameter Name="Entity" Type="Edm.EntityType" Nullable="false">
          <Annotation Term="Core.Description" String="The entity to become a root or an orphan" />
        </Parameter>
        <Parameter Name="HierarchyQualifier" Type="Aggregation.HierarchyQualifier" Nullable="false">
          <Annotation Term="Core.Description" String="Qualifier of a [`RecursiveHierarchy`](#RecursiveHierarchy) annotation on the binding parameter's entity type" />
        </Parameter>
        <Parameter Name="Parent" Type="Edm.EntityType" Nullable="false">
          <Annotation Term="Core.Description" String="Key of the entity's former parent" />
          <Annotation Term="Core.LongDescription">
            <String>In the absence of this parameter, the child is removed from its only parent.</String>
          </Annotation>
          <Annotation Term="Core.OptionalParameter">
            <Record/>
          </Annotation>
        </Parameter>
      </Action>
      <Action Name="Template_PositionAction" IsBound="true">
        <Annotation Term="Common.Experimental" />
        <Annotation Term="Core.Description" String="Template for actions that position a node among its siblings and are named in [`RecursiveHierarchy/PositionAction`](#RecursiveHierarchyType)" />
        <Parameter Name="Entity" Type="Edm.EntityType" Nullable="false">
          <Annotation Term="Core.Description" String="The entity to be positioned" />
        </Parameter>
        <Parameter Name="HierarchyQualifier" Type="Aggregation.HierarchyQualifier" Nullable="false">
          <Annotation Term="Core.Description" String="Qualifier of a [`RecursiveHierarchy`](#RecursiveHierarchy) annotation on the binding parameter's entity type" />
        </Parameter>
        <Parameter Name="NextSibling" Type="Edm.EntityType" Nullable="true">
          <Annotation Term="Core.Description" String="Key of the node's next sibling (null if the node shall become the last sibling)" />
        </Parameter>
      </Action>

    </Schema>
  </edmx:DataServices>
</edmx:Edmx>
